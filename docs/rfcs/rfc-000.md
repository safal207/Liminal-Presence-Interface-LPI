# RFC-000: The Liminal Resonance Interface (LRI) — Overview

**Status:** Draft
**Author(s):** LRI Contributors
**Created:** 2025-01-15
**Updated:** 2025-01-15
**Version:** 0.1.0

---

## Table of Contents

- [Abstract](#abstract)
- [1. Problem Statement](#1-problem-statement)
- [2. Motivation](#2-motivation)
- [3. Scope](#3-scope)
- [4. Non-Goals](#4-non-goals)
- [5. Terminology](#5-terminology)
- [6. Architecture](#6-architecture)
- [7. Layer 8: Semantic Protocol Layer](#7-layer-8-semantic-protocol-layer)
- [8. LCE: Liminal Context Envelope](#8-lce-liminal-context-envelope)
- [9. On-Wire Format](#9-on-wire-format)
- [10. Protocol Subsystems](#10-protocol-subsystems)
- [11. Media Types](#11-media-types)
- [12. Compatibility and Encapsulation](#12-compatibility-and-encapsulation)
- [13. Security Considerations](#13-security-considerations)
- [14. Privacy and Consent](#14-privacy-and-consent)
- [15. Versioning and Evolution](#15-versioning-and-evolution)
- [16. Implementation Guidelines](#16-implementation-guidelines)
- [17. Use Cases](#17-use-cases)
- [18. References](#18-references)

---

## Abstract

The **Liminal Resonance Interface (LRI)** is a semantic communication protocol that operates as **Layer 8** above the traditional OSI Layer 7 (Application). LRI enriches application-level messages with contextual metadata including **intent** (what the message aims to achieve), **affect** (emotional context), **consent** (privacy policy), **coherence** (quality metrics), **trust** (cryptographic proofs), and **memory** (session continuity).

LRI enables human-AI systems to communicate with semantic clarity, emotional awareness, and explicit consent, addressing the gap between raw data transmission and meaningful interaction.

---

## 1. Problem Statement

### 1.1 Current State

Existing application protocols (HTTP, WebSocket, gRPC) excel at transporting **data** but provide no standardized way to convey **meaning**:

- **No intent signaling:** Is this a question, statement, proposal, or confirmation?
- **No emotional context:** Is the user frustrated, curious, or urgent?
- **Implicit consent:** Privacy policies are external, not embedded in messages
- **No quality metrics:** How coherent is the conversation? Is context drifting?
- **No trust framework:** Messages lack cryptographic authenticity
- **Stateless interactions:** Session context is ad-hoc, not standardized

### 1.2 Consequences

This semantic gap leads to:

1. **Misaligned AI responses** - AI misinterprets user intent
2. **Privacy violations** - No explicit consent per message
3. **Context loss** - Conversations lose coherence over time
4. **Trust issues** - No proof of message authenticity
5. **Poor UX** - Systems can't adapt to emotional state
6. **Compliance risks** - No audit trail for data sharing

### 1.3 The Solution: Layer 8

LRI introduces a **semantic layer** that sits above application protocols, wrapping messages with rich contextual metadata while remaining **protocol-agnostic** and **backward-compatible**.

---

## 2. Motivation

### 2.1 Why Now?

The rise of large language models (LLMs) and AI assistants has created unprecedented demand for **semantic clarity** in human-AI communication:

- **AI ambiguity** - LLMs need explicit intent to reduce hallucinations
- **Privacy regulations** - GDPR, CCPA require explicit consent
- **Multi-agent systems** - Agents need semantic routing
- **Context windows** - Limited context requires efficient semantic encoding
- **Trust requirements** - Enterprise AI needs proof of authenticity

### 2.2 Design Principles

LRI is built on five core principles:

1. **Semantic-first** - Meaning matters more than bytes
2. **Privacy by design** - Explicit consent on every message
3. **Layered approach** - Works with existing protocols
4. **Human-centric** - Optimized for human-AI interaction
5. **Open standard** - Community-driven, vendor-neutral

### 2.3 Inspiration

LRI draws inspiration from:

- **OSI Model** - Layered network architecture
- **MIME Types** - Content-type negotiation
- **HTTP/2 Headers** - Metadata in headers
- **PAD Model** - Pleasure-Arousal-Dominance emotional model
- **Speech Acts** - Linguistic theory of communicative intent
- **Zero Trust** - Explicit authentication per message

---

## 3. Scope

### 3.1 What LRI Includes

**Core Protocol:**
- LCE (Liminal Context Envelope) - semantic metadata structure
- Intent vocabulary - standardized communicative intent types
- Affect model - emotional context (PAD + tags)
- Consent policy - privacy and data sharing rules
- Quality metrics - coherence, stability tracking

**Subsystems:**
- LHS (Liminal Handshake Sequence) - connection establishment
- LTP (Liminal Trust Protocol) - cryptographic signatures
- LSS (Liminal Session Store) - context memory

**Transport Bindings:**
- HTTP headers
- WebSocket frames
- gRPC metadata
- CBOR encoding for IoT

### 3.2 What LRI Provides

- Standardized semantic metadata format
- Schema validation (JSON Schema)
- SDKs for major languages
- Protocol specifications
- Example implementations
- Security guidelines

---

## 4. Non-Goals

LRI explicitly **does not**:

1. **Replace existing protocols** - LRI wraps HTTP/WS/gRPC, doesn't replace them
2. **Define application logic** - LRI provides context, not business rules
3. **Guarantee AI behavior** - LRI helps AI understand intent, doesn't control responses
4. **Handle encryption** - Use TLS; LRI adds semantic layer, not transport security
5. **Store data** - LRI defines session context, not persistence layer
6. **Enforce consent** - LRI signals policy, application must enforce
7. **Compete with REST/GraphQL** - LRI is orthogonal to API design patterns

---

## 5. Terminology

### 5.1 Core Terms

**LRI (Liminal Resonance Interface)**
The overall protocol and ecosystem. "Liminal" refers to the threshold/transitional space between human and AI cognition.

**Layer 8**
Semantic layer above OSI Layer 7 (Application). Provides meaning, not just data.

**LCE (Liminal Context Envelope)**
The data structure that wraps messages with semantic metadata. The fundamental unit of LRI.

### 5.2 Subsystems

**LHS (Liminal Handshake Sequence)**
Protocol for establishing LRI-aware connections (primarily for WebSocket). Steps: Hello → Mirror → Bind → Seal → Flow.

**LTP (Liminal Trust Protocol)**
Cryptographic framework for signing and verifying LCE messages using JWS (JSON Web Signature) and JCS (JSON Canonicalization Scheme).

**LSS (Liminal Session Store)**
Context memory system that tracks conversation threads, calculates coherence scores, and detects semantic drift.

### 5.3 Semantic Terms

**Intent**
The communicative goal of a message (e.g., ask, tell, propose, confirm).

**Affect**
Emotional context using PAD model (Pleasure, Arousal, Dominance) and semantic tags.

**Consent**
Privacy policy level: private, team, or public.

**Coherence**
Quality metric (0-1) measuring semantic alignment in conversation.

**Provenance**
Chain of custody tracking who handled the message.

---

## 6. Architecture

### 6.1 OSI Model Extension

```
┌─────────────────────────────────────────────────────────────┐
│  Layer 8: LRI (Semantic/Context Layer)                      │
│  - Intent, Affect, Consent, Memory, Trust, QoS             │
│  - LCE structure with metadata                              │
├─────────────────────────────────────────────────────────────┤
│  Layer 7: Application (HTTP, WebSocket, gRPC, AMQP)        │
│  - Request/Response, Streaming, RPC                         │
├─────────────────────────────────────────────────────────────┤
│  Layer 6: Presentation (TLS, Encoding)                      │
├─────────────────────────────────────────────────────────────┤
│  Layer 5: Session                                            │
├─────────────────────────────────────────────────────────────┤
│  Layer 4: Transport (TCP, UDP)                              │
├─────────────────────────────────────────────────────────────┤
│  Layer 3: Network (IP)                                       │
├─────────────────────────────────────────────────────────────┤
│  Layer 2: Data Link                                          │
├─────────────────────────────────────────────────────────────┤
│  Layer 1: Physical                                           │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 Protocol Stack Comparison

| Layer | Traditional | With LRI |
|-------|-------------|----------|
| 8 | — | **LRI** (intent, affect, consent) |
| 7 | HTTP/WS | HTTP/WS (unchanged) |
| 6 | TLS | TLS (unchanged) |
| 5-1 | TCP/IP | TCP/IP (unchanged) |

### 6.3 Information Flow

```
┌──────────────┐                              ┌──────────────┐
│   Human      │                              │   AI Agent   │
└──────┬───────┘                              └──────┬───────┘
       │                                             │
       │ 1. Create message with intent              │
       │    "What's the weather?"                   │
       │    Intent: ask, Affect: curious            │
       │                                             │
       ▼                                             │
┌──────────────────────────────────────────┐        │
│  LRI Layer 8: Wrap with LCE              │        │
│  {                                       │        │
│    v: 1,                                 │        │
│    intent: {type: "ask"},                │        │
│    affect: {tags: ["curious"]},          │        │
│    policy: {consent: "private"}          │        │
│  }                                       │        │
└──────┬───────────────────────────────────┘        │
       │                                             │
       │ 2. Encode to Base64                        │
       │    LCE: eyJ2IjoxLCJpbnRlbnQi...            │
       │                                             │
       ▼                                             │
┌──────────────────────────────────────────┐        │
│  Layer 7: HTTP POST /api/chat            │        │
│  Header: LCE: eyJ2IjoxLCJpbnRlbnQi...    │        │
│  Body: {"message": "What's weather?"}    │        │
└──────┬───────────────────────────────────┘        │
       │                                             │
       │ 3. Transport over network                  │
       │                                             │
       └─────────────────────────────────────────►  │
                                                     │
       ┌─────────────────────────────────────────┐  │
       │  Layer 7: Receive HTTP request          │◄─┘
       │  Extract LCE header                     │
       └──────┬──────────────────────────────────┘
              │
              ▼
       ┌──────────────────────────────────────────┐
       │  LRI Layer 8: Parse LCE                  │
       │  - Validate schema                       │
       │  - Extract intent: "ask"                 │
       │  - Extract affect: "curious"             │
       │  - Check consent: "private"              │
       │  - Calculate coherence                   │
       └──────┬───────────────────────────────────┘
              │
              │ 4. Process with semantic context
              │
              ▼
       ┌──────────────┐
       │  AI Agent    │
       │  processes   │
       │  with intent │
       └──────────────┘
```

---

## 7. Layer 8: Semantic Protocol Layer

### 7.1 Rationale

Why a new layer?

1. **Separation of concerns** - Semantic metadata separate from application data
2. **Protocol independence** - Works with any Layer 7 protocol
3. **Optional adoption** - Clients without LRI still work (graceful degradation)
4. **Composability** - Can be added to existing systems
5. **Evolvability** - Layer 8 can evolve independently

### 7.2 Layer 8 Responsibilities

**Input (from Layer 7):**
- Raw application messages
- Connection metadata

**Processing:**
- Attach semantic context (LCE)
- Validate schema
- Verify signatures (LTP)
- Track coherence (LSS)
- Log consent audit trail

**Output (to application):**
- Enriched messages with context
- Quality metrics
- Trust status

### 7.3 Interaction with Layer 7

LRI integrates with existing Layer 7 protocols through:

**HTTP:**
```http
POST /api/chat HTTP/1.1
Host: example.com
Content-Type: application/json
LCE: eyJ2IjoxLCJpbnRlbnQiOnsidHlwZSI6ImFzayJ9...

{"message": "What's the weather?"}
```

**WebSocket:**
```
┌─────────────┬──────────────────────────┐
│ LCE (JSON)  │  Payload                 │
│ (80 bytes)  │  (variable)              │
└─────────────┴──────────────────────────┘
     ▲
     │
  Frame prefix
```

**gRPC:**
```protobuf
metadata {
  key: "lce"
  value: "eyJ2IjoxLCJpbnRlbnQi..."
}
```

---

## 8. LCE: Liminal Context Envelope

### 8.1 Structure

The LCE is the core data structure of LRI:

```json
{
  "v": 1,
  "intent": {
    "type": "ask",
    "goal": "Optional human-readable goal"
  },
  "affect": {
    "pad": [0.3, 0.2, 0.1],
    "tags": ["curious", "casual"]
  },
  "meaning": {
    "topic": "weather",
    "ontology": "https://schema.org/WeatherForecast"
  },
  "trust": {
    "proof": "JWS signature",
    "attest": ["attestation URIs"]
  },
  "memory": {
    "thread": "550e8400-e29b-41d4-a716-446655440000",
    "t": "2025-01-15T10:30:00Z",
    "ttl": "PT1H"
  },
  "policy": {
    "consent": "private",
    "share": ["allowed-service-ids"],
    "dp": "epsilon=1.0"
  },
  "qos": {
    "coherence": 0.87,
    "stability": "high"
  },
  "trace": {
    "hop": 0,
    "provenance": ["origin-id"]
  },
  "sig": "JWS compact serialization"
}
```

### 8.2 Field Definitions

#### 8.2.1 Version (`v`)
- **Type:** Integer
- **Required:** Yes
- **Value:** 1 (current version)
- **Purpose:** Schema version for forward compatibility

#### 8.2.2 Intent (`intent`)
- **Type:** Object
- **Required:** Yes
- **Fields:**
  - `type` (required): Enum of intent types
  - `goal` (optional): Human-readable goal

**Intent Types:**
- `ask` - Request information or action
- `tell` - Provide information or state facts
- `propose` - Suggest an action or approach
- `confirm` - Acknowledge or verify
- `notify` - Alert without expecting response
- `sync` - Request/establish shared context
- `plan` - Outline future actions
- `agree` - Express agreement
- `disagree` - Express disagreement or alternative
- `reflect` - Introspect or reason

#### 8.2.3 Affect (`affect`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `pad`: Array of 3 floats [-1, 1] (Pleasure, Arousal, Dominance)
  - `tags`: Array of strings (semantic tags)

**PAD Model:**
- **Pleasure:** Positive (pleasant) to negative (unpleasant)
- **Arousal:** High activation (alert) to low activation (calm)
- **Dominance:** Feeling in control to feeling controlled

**Example tags:** curious, urgent, casual, analytical, frustrated

#### 8.2.4 Meaning (`meaning`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `topic`: Semantic topic or domain
  - `ontology`: Reference ontology URI (e.g., schema.org)

#### 8.2.5 Trust (`trust`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `proof`: Cryptographic proof (JWS signature)
  - `attest`: Third-party attestations

#### 8.2.6 Memory (`memory`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `thread`: Conversation thread UUID
  - `t`: Timestamp (ISO 8601)
  - `ttl`: Time-to-live (ISO 8601 duration)

#### 8.2.7 Policy (`policy`)
- **Type:** Object
- **Required:** Yes
- **Fields:**
  - `consent` (required): Enum of consent levels
  - `share`: Whitelist of allowed recipients
  - `dp`: Differential privacy parameters

**Consent Levels:**
- `private` - Personal use only, do not share
- `team` - Shareable within team/organization
- `public` - Publicly shareable

#### 8.2.8 QoS (`qos`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `coherence`: Float [0, 1] - semantic coherence score
  - `stability`: String - context stability indicator

#### 8.2.9 Trace (`trace`)
- **Type:** Object
- **Required:** No
- **Fields:**
  - `hop`: Integer - number of intermediary hops
  - `provenance`: Array of strings - chain of custody

#### 8.2.10 Signature (`sig`)
- **Type:** String
- **Required:** No
- **Value:** JWS compact serialization
- **Purpose:** Cryptographic signature of canonical JSON

### 8.3 Minimal LCE

Smallest valid LCE:

```json
{
  "v": 1,
  "intent": {"type": "tell"},
  "policy": {"consent": "private"}
}
```

Size: ~60 bytes

### 8.4 Validation

All LCE messages MUST:
1. Validate against JSON Schema (schemas/lce-v0.1.json)
2. Have `v`, `intent`, `policy` fields
3. Use valid enum values
4. Follow field type constraints

---

## 9. On-Wire Format

### 9.1 Encoding Modes

LRI supports two encoding modes:

#### 9.1.1 JSON Mode (Default)
- **Media type:** `application/liminal.lce+json`
- **Format:** UTF-8 encoded JSON
- **Transport:** Base64 in HTTP headers, raw in WS frames
- **Use case:** Human-readable, standard tooling

#### 9.1.2 CBOR Mode (IoT/Embedded)
- **Media type:** `application/liminal.lce+cbor`
- **Format:** CBOR (RFC 8949)
- **Signatures:** COSE instead of JWS
- **Use case:** Low bandwidth, binary protocols

### 9.2 HTTP Transport

#### Request with LCE:
```http
POST /api/chat HTTP/1.1
Host: example.com
Content-Type: application/json
LCE: eyJ2IjoxLCJpbnRlbnQiOnsidHlwZSI6ImFzayIsImdvYWwiOiJHZXQgd2VhdGhlciJ9LCJwb2xpY3kiOnsiY29uc2VudCI6InByaXZhdGUifX0=

{"message": "What's the weather in SF?"}
```

LCE header value is Base64(JSON.stringify(lce))

#### Response with LCE:
```http
HTTP/1.1 200 OK
Content-Type: application/liminal.lce+json
LCE: eyJ2IjoxLCJpbnRlbnQiOnsidHlwZSI6InRlbGwifSwicG9saWN5Ijp7ImNvbnNlbnQiOiJwcml2YXRlIn19

{"message": "It's 68°F and sunny in San Francisco"}
```

### 9.3 WebSocket Transport

#### Frame Structure:
```
┌────────────────┬──────────────────────────┐
│ LCE Length (4) │ LCE JSON                 │
└────────────────┴─────────┬────────────────┘
                           │
                           ▼
                  ┌────────────────────────┐
                  │ Application Payload    │
                  └────────────────────────┘
```

- First 4 bytes: LCE length (uint32, network byte order)
- Next N bytes: LCE JSON
- Remaining bytes: Application payload

#### Example:
```
[0x00, 0x00, 0x00, 0x3C]  // Length: 60 bytes
[{...LCE...}]              // 60 bytes of LCE JSON
[{...payload...}]          // Application data
```

### 9.4 gRPC Transport

#### Metadata:
```protobuf
service ChatService {
  rpc SendMessage(ChatRequest) returns (ChatResponse);
}

// Client sends:
metadata: {
  "lce": "eyJ2IjoxLCJpbnRlbnQi..."
}

// Server responds:
metadata: {
  "lce": "eyJ2IjoxLCJpbnRlbnQi..."
}
```

---

## 10. Protocol Subsystems

### 10.1 LHS: Liminal Handshake Sequence

**Purpose:** Establish LRI-aware WebSocket connections with negotiated capabilities.

#### Sequence:

```
Client                                Server
  │                                     │
  │  1. Hello (capabilities)            │
  ├────────────────────────────────────►│
  │    {                                │
  │      "lri_version": "0.1",          │
  │      "encodings": ["json", "cbor"], │
  │      "features": ["ltp", "lss"]     │
  │    }                                │
  │                                     │
  │  2. Mirror (echo + server caps)     │
  │◄────────────────────────────────────┤
  │    {                                │
  │      "lri_version": "0.1",          │
  │      "encoding": "json",             │
  │      "features": ["ltp"]            │
  │    }                                │
  │                                     │
  │  3. Bind (session context)          │
  ├────────────────────────────────────►│
  │    {                                │
  │      "thread": "uuid",              │
  │      "auth": "token"                │
  │    }                                │
  │                                     │
  │  4. Seal (crypto commitment)        │
  │◄────────────────────────────────────┤
  │    {                                │
  │      "session_id": "uuid",          │
  │      "sig": "JWS..."                │
  │    }                                │
  │                                     │
  │  5. Flow (regular LCE exchange)     │
  │◄───────────────────────────────────►│
  │    [LCE + Payload]                  │
  │                                     │
```

### 10.2 LTP: Liminal Trust Protocol

**Purpose:** Cryptographic signing and verification of LCE messages.

#### Components:

1. **JCS (JSON Canonicalization Scheme, RFC 8785)**
   - Deterministic JSON serialization
   - Consistent key ordering
   - No whitespace variations

2. **JWS (JSON Web Signature, RFC 7515)**
   - Compact serialization format
   - Ed25519 signatures (recommended)
   - Header: `{"alg": "EdDSA", "typ": "LCE"}`

#### Signing Process:

```javascript
// 1. Create LCE without signature
const lce = {
  v: 1,
  intent: {type: "tell"},
  policy: {consent: "private"},
  // ... other fields
};

// 2. Canonicalize JSON
const canonical = JCS.canonicalize(lce);

// 3. Create JWS
const header = {alg: "EdDSA", typ: "LCE"};
const signature = sign(header, canonical, privateKey);

// 4. Add signature to LCE
lce.sig = signature;
```

#### Verification:

```javascript
// 1. Extract LCE
const {sig, ...lceWithoutSig} = receivedLCE;

// 2. Canonicalize
const canonical = JCS.canonicalize(lceWithoutSig);

// 3. Verify JWS
const valid = verify(sig, canonical, publicKey);
```

### 10.3 LSS: Liminal Session Store

**Purpose:** Track conversation context, calculate coherence, detect drift.

#### Coherence Calculation:

```
coherence = α·intent_similarity + β·affect_stability + γ·semantic_alignment

where:
  α = 0.4 (intent weight)
  β = 0.3 (affect weight)
  γ = 0.3 (semantic weight)
```

**Intent Similarity:**
- Track intent sequence
- Cosine similarity of intent vectors
- Penalize erratic switches

**Affect Stability:**
- Track PAD vector changes
- Calculate variance over window
- Smooth vs. volatile

**Semantic Alignment:**
- Track topic/ontology consistency
- Measure topic drift
- Domain coherence

#### Example:

```javascript
// Conversation
const messages = [
  {intent: {type: "ask"}, affect: {pad: [0.3, 0.2, 0.1]}},
  {intent: {type: "tell"}, affect: {pad: [0.4, 0.1, 0.2]}},
  {intent: {type: "ask"}, affect: {pad: [0.3, 0.3, 0.1]}},
];

// Calculate coherence
const coherence = LSS.calculate(messages);
// → 0.85 (high coherence)
```

---

## 11. Media Types

### 11.1 JSON Mode

**MIME Type:** `application/liminal.lce+json`

**Content-Type Header:**
```http
Content-Type: application/liminal.lce+json; version=1
```

**Accept Header:**
```http
Accept: application/liminal.lce+json
```

### 11.2 CBOR Mode

**MIME Type:** `application/liminal.lce+cbor`

**Content-Type Header:**
```http
Content-Type: application/liminal.lce+cbor; version=1
```

**Size Comparison:**

| Format | Minimal LCE | Full LCE |
|--------|-------------|----------|
| JSON | ~60 bytes | ~400 bytes |
| CBOR | ~40 bytes | ~280 bytes |
| Savings | 33% | 30% |

---

## 12. Compatibility and Encapsulation

### 12.1 Backward Compatibility

**Graceful Degradation:**

1. **LRI-aware client + LRI-aware server** → Full LRI features
2. **LRI-aware client + Legacy server** → Client sends LCE, server ignores
3. **Legacy client + LRI-aware server** → Server provides defaults
4. **Legacy client + Legacy server** → Normal operation (no LRI)

### 12.2 HTTP Integration

**Rules:**
- LCE in `LCE` header (Base64 encoded)
- Application data in body (unchanged)
- Content-Type can include LCE media type

**Example Integration:**

```typescript
// Express middleware (LRI-aware)
app.use(lriMiddleware());

app.post('/api/chat', (req, res) => {
  // Access LCE
  const lce = req.lri?.lce;

  // Access regular body
  const message = req.body.message;

  // Process with intent awareness
  if (lce?.intent.type === 'ask') {
    // Handle question
  }
});
```

### 12.3 REST/GraphQL Compatibility

LRI is **orthogonal** to REST/GraphQL:

**REST + LRI:**
```http
GET /api/users/123
LCE: eyJ2IjoxLCJpbnRlbnQi...
```

**GraphQL + LRI:**
```http
POST /graphql
LCE: eyJ2IjoxLCJpbnRlbnQi...

query { user(id: "123") { name } }
```

---

## 13. Security Considerations

### 13.1 Threat Model

See [SECURITY.md](../../SECURITY.md) and Issue #17 for full STRIDE analysis.

**Key Threats:**

1. **Spoofing** - Fake LCE messages
   - **Mitigation:** LTP signatures

2. **Tampering** - Modified LCE
   - **Mitigation:** JCS + JWS

3. **Repudiation** - Deny sending message
   - **Mitigation:** Signed audit log

4. **Information Disclosure** - Privacy leaks
   - **Mitigation:** Consent policy, encryption

5. **Denial of Service** - Large LCE payloads
   - **Mitigation:** Size limits, TTL

6. **Elevation of Privilege** - Consent bypass
   - **Mitigation:** Application enforcement

### 13.2 Security Requirements

**MUST:**
- Validate LCE against schema
- Check consent before sharing data
- Use TLS for transport
- Implement size limits (< 10KB)
- Log consent decisions

**SHOULD:**
- Sign LCE with LTP
- Verify signatures
- Implement replay protection (nonce + timestamp)
- Rate limit LCE validation
- Sanitize user-provided fields

**MAY:**
- Use CBOR for bandwidth savings
- Implement custom ontologies
- Extend with proprietary fields (prefixed with `x-`)

---

## 14. Privacy and Consent

### 14.1 Privacy by Design

Every LCE **MUST** include a `policy.consent` field:

```json
{
  "policy": {
    "consent": "private"  // Required
  }
}
```

### 14.2 Consent Levels

| Level | Meaning | Example Use Case |
|-------|---------|------------------|
| `private` | Personal use only, do not share | Personal chat, medical data |
| `team` | Shareable within team/org | Enterprise collaboration |
| `public` | Publicly shareable | Public forum, open data |

### 14.3 Enforcement

**Application Responsibility:**

```typescript
function canShare(lce: LCE, recipient: string): boolean {
  switch (lce.policy.consent) {
    case 'private':
      return false; // Never share
    case 'team':
      return lce.policy.share?.includes(recipient) ?? false;
    case 'public':
      return true;
  }
}
```

### 14.4 Audit Trail

**Log Format:**

```json
{
  "timestamp": "2025-01-15T10:30:00Z",
  "from": "user@example.com",
  "to": "ai-service",
  "consent": "team",
  "thread": "uuid",
  "sig": "audit-signature"
}
```

---

## 15. Versioning and Evolution

### 15.1 Semantic Versioning

**LRI Version Format:** `MAJOR.MINOR.PATCH`

- **MAJOR:** Breaking changes (e.g., required field added)
- **MINOR:** New features (backward compatible)
- **PATCH:** Bug fixes

**Current:** `0.1.0` (alpha)

### 15.2 LCE Version Field

```json
{
  "v": 1  // Schema version
}
```

**Negotiation:**

```http
Accept: application/liminal.lce+json; version=1
Content-Type: application/liminal.lce+json; version=1
```

### 15.3 Compatibility Rules

**Forward Compatibility:**
- Old clients MUST ignore unknown fields
- New servers MUST support old LCE versions

**Backward Compatibility:**
- New clients SHOULD support old servers
- Old servers ignore LCE headers (graceful degradation)

### 15.4 Deprecation Policy

**Timeline:**
- `v1.x` supported for 2 years after `v2.0` release
- Deprecation warnings 6 months before EOL
- Migration guide provided

---

## 16. Implementation Guidelines

### 16.1 Server Implementation

**Checklist:**

- [ ] Parse LCE from header/frame
- [ ] Validate against JSON Schema
- [ ] Extract intent, affect, policy
- [ ] Check consent before processing
- [ ] Calculate coherence (if LSS enabled)
- [ ] Verify signature (if LTP enabled)
- [ ] Log for audit trail
- [ ] Respond with LCE

### 16.2 Client Implementation

**Checklist:**

- [ ] Create LCE for outgoing messages
- [ ] Set appropriate intent type
- [ ] Include consent level
- [ ] Encode to Base64 (HTTP) or prefix (WS)
- [ ] Set LCE header/frame
- [ ] Parse LCE from responses
- [ ] Track thread ID for continuity

### 16.3 Middleware Pattern

**Node.js (Express):**

```typescript
import { lriMiddleware } from 'node-lri';

app.use(lriMiddleware({
  required: false,
  validate: true
}));
```

**Python (FastAPI):**

```python
from lri import LRI

lri = LRI()

@app.get("/api/data")
async def endpoint(request: Request):
    lce = await lri.parse_request(request)
    # Use lce.intent, lce.affect, etc.
```

---

## 17. Use Cases

### 17.1 AI Chat Applications

**Problem:** AI misinterprets ambiguous queries

**Solution:** Explicit intent signaling

```json
// User asks question
{
  "intent": {"type": "ask", "goal": "Get recommendation"},
  "affect": {"tags": ["curious"]},
  "policy": {"consent": "private"}
}

// AI responds with recommendation
{
  "intent": {"type": "tell"},
  "affect": {"tags": ["helpful"]},
  "qos": {"coherence": 0.92}
}
```

### 17.2 Multi-Agent Systems

**Problem:** Agents need semantic routing

**Solution:** Route based on intent type

```typescript
function route(lce: LCE, message: any) {
  switch (lce.intent.type) {
    case 'ask':
      return queryAgent;
    case 'plan':
      return plannerAgent;
    case 'notify':
      return loggingAgent;
  }
}
```

### 17.3 Compliance & Audit

**Problem:** No audit trail for data sharing

**Solution:** Consent embedded in every message

```typescript
// Before sharing
if (lce.policy.consent !== 'public') {
  throw new Error('Cannot share private data');
}

// Log
audit.log({
  action: 'share',
  consent: lce.policy.consent,
  timestamp: new Date()
});
```

### 17.4 Context Preservation

**Problem:** Long conversations lose coherence

**Solution:** Track coherence via LSS

```typescript
const coherence = await lss.calculate(threadId);

if (coherence < 0.5) {
  // Prompt user to clarify context
  respond({
    intent: {type: 'sync'},
    message: 'Let me make sure I understand...'
  });
}
```

### 17.5 Emotional Awareness

**Problem:** AI doesn't adapt to user emotional state

**Solution:** Affect-aware responses

```typescript
if (lce.affect?.tags?.includes('frustrated')) {
  // Use empathetic tone
  respond({
    intent: {type: 'confirm'},
    affect: {tags: ['empathetic']},
    message: 'I understand this is frustrating...'
  });
}
```

---

## 18. References

### 18.1 Standards

- **RFC 8259:** JSON Specification
- **RFC 8785:** JSON Canonicalization Scheme (JCS)
- **RFC 7515:** JSON Web Signature (JWS)
- **RFC 8949:** CBOR Specification
- **RFC 8152:** COSE (CBOR Object Signing and Encryption)
- **ISO 8601:** Date and Time Format

### 18.2 Related Work

- **OSI Model:** ISO/IEC 7498-1
- **MIME Types:** RFC 2046
- **HTTP/2:** RFC 7540
- **WebSocket:** RFC 6455
- **gRPC:** https://grpc.io/docs/

### 18.3 Theoretical Background

- **PAD Model:** Russell & Mehrabian (1977)
- **Speech Act Theory:** Austin (1962), Searle (1969)
- **Grice's Maxims:** Grice (1975)
- **Zero Trust Architecture:** NIST SP 800-207

### 18.4 LRI Resources

- **Website:** https://lri.dev (coming soon)
- **GitHub:** https://github.com/lri/lri
- **Schema:** https://lri.dev/schema/lce-v0.1.json
- **Docs:** https://lri.dev/docs

---

## Appendix A: Complete LCE Example

```json
{
  "v": 1,
  "intent": {
    "type": "ask",
    "goal": "Get weather forecast for travel planning"
  },
  "affect": {
    "pad": [0.3, 0.5, 0.2],
    "tags": ["curious", "planning"]
  },
  "meaning": {
    "topic": "weather-forecast",
    "ontology": "https://schema.org/WeatherForecast"
  },
  "trust": {
    "proof": "eyJhbGciOiJFZERTQSIsInR5cCI6IkxDRSJ9...",
    "attest": ["https://trusted-authority.com/attest/user123"]
  },
  "memory": {
    "thread": "550e8400-e29b-41d4-a716-446655440000",
    "t": "2025-01-15T10:30:00Z",
    "ttl": "PT1H"
  },
  "policy": {
    "consent": "team",
    "share": ["weather-service", "calendar-service"],
    "dp": "epsilon=1.0,delta=1e-5"
  },
  "qos": {
    "coherence": 0.87,
    "stability": "high"
  },
  "trace": {
    "hop": 2,
    "provenance": [
      "user-client-v1.0",
      "api-gateway-v2.1",
      "weather-service-v3.5"
    ]
  },
  "sig": "eyJhbGciOiJFZERTQSIsInR5cCI6IkxDRSJ9.eyJ2IjoxLCJpbnRlbnQiOnsidHlwZSI6ImFzayJ9fQ.signature"
}
```

---

## Appendix B: FAQ

**Q: Do I need to use all LCE fields?**
A: No. Only `v`, `intent`, and `policy` are required. Use optional fields as needed.

**Q: Can I extend LCE with custom fields?**
A: Yes, prefix custom fields with `x-` (e.g., `x-myapp-feature`).

**Q: What's the overhead?**
A: Minimal LCE: ~60 bytes. Full LCE: ~400 bytes. Typically <10% overhead.

**Q: Do I need to replace my existing API?**
A: No. LRI wraps existing APIs. Your endpoints remain unchanged.

**Q: Is LRI only for AI?**
A: No, but it's optimized for human-AI. Human-human chat benefits too.

**Q: How do I get started?**
A: Install SDKs (`npm install node-lri` or `pip install python-lri`), add middleware, start using LCE.

---

## Appendix C: Glossary

- **L7:** Layer 7 (Application Layer)
- **L8:** Layer 8 (Semantic Layer)
- **JCS:** JSON Canonicalization Scheme
- **JWS:** JSON Web Signature
- **PAD:** Pleasure-Arousal-Dominance
- **LCE:** Liminal Context Envelope
- **LHS:** Liminal Handshake Sequence
- **LTP:** Liminal Trust Protocol
- **LSS:** Liminal Session Store

---

## Document History

| Version | Date | Changes |
|---------|------|---------|
| 0.1.0 | 2025-01-15 | Initial draft |

---

**End of RFC-000**
